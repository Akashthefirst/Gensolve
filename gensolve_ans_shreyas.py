# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/187rXRLw3Ib9TQDhXRBFNkt7xSDoQURYa
"""

!pip install svgwrite cairosvg

import numpy as np
import matplotlib.pyplot as plt
import svgwrite
import cairosvg
import matplotlib.image as mpimg
from PIL import Image
import re
from google.colab import files

# Define test case groups
BORDER_TEST_CASES = ['frag0.csv', 'frag0_sol.csv', 'frag1.csv', 'frag2.csv', 'frag2_sol.csv', 'isolated.csv', 'isolated_sol.csv', 'occlusion1_rec.csv']
POLYGON_TEST_CASES = ['occlusion1.csv', 'occlusion1_sol.csv', 'occlusion2.csv', 'occlusion2_sol.csv']

# Utility function to clean filenames
def clean_filename(filename):
    return re.sub(r'\s\(\d+\)', '', filename)

# Function to read CSV file and return structured paths data
def load_csv_data(filepath):
    data = np.genfromtxt(filepath, delimiter=',')
    paths = {}
    for group_id in np.unique(data[:, 0]):
        group_data = data[data[:, 0] == group_id][:, 1:]
        paths[group_id] = [group_data[group_data[:, 0] == sub_id][:, 1:] for sub_id in np.unique(group_data[:, 0])]
    return paths

# Function to calculate the SVG canvas size
def calculate_svg_size(paths):
    max_x, max_y = 0, 0
    for group_paths in paths.values():
        for path in group_paths:
            max_x = max(max_x, np.max(path[:, 0]))
            max_y = max(max_y, np.max(path[:, 1]))
    padding = 0.1
    return int(max_x + padding * max_x), int(max_y + padding * max_y)

# Function to save paths as SVG and PNG
def save_paths_as_svg(paths, filename, colors):
    width, height = calculate_svg_size(paths)
    dwg = svgwrite.Drawing(filename, size=(width, height), profile='tiny')

    for i, (group_id, group_paths) in enumerate(paths.items()):
        color = colors[i % len(colors)]
        for path in group_paths:
            path_commands = " ".join([f"L {x},{y}" for x, y in path])
            path_string = f"M {path[0][0]},{path[0][1]} {path_commands} Z"
            dwg.add(dwg.path(d=path_string, fill=color, stroke='black', stroke_width=2))

    dwg.save()
    cairosvg.svg2png(url=filename, write_to=filename.replace('.svg', '.png'))

# Function to plot paths on a Matplotlib figure
def plot_paths(paths, colors, filled=False):
    fig, ax = plt.subplots(figsize=(8, 8))
    for i, group_paths in enumerate(paths.values()):
        color = colors[i % len(colors)]
        for path in group_paths:
            if filled:
                ax.fill(path[:, 0], path[:, 1], c=color, edgecolor='black', linewidth=2)
            else:
                ax.plot(path[:, 0], path[:, 1], color=color, linewidth=2)
    ax.set_aspect('equal')
    plt.gca().invert_yaxis()
    plt.show()

# Function to handle polygon files
def handle_polygon_file(filename, colors):
    paths = load_csv_data(filename)
    plot_paths(paths, colors, filled=True)
    save_paths_as_svg(paths, filename.replace('.csv', '.svg'), colors)

# Function to handle border files
def handle_border_file(filename, colors):
    paths = load_csv_data(filename)
    plot_paths(paths, colors, filled=False)
    save_paths_as_svg(paths, filename.replace('.csv', '.svg'), colors)

# Function to handle image files
def display_image_file(filename):
    img = mpimg.imread(filename)
    plt.imshow(img)
    plt.axis('off')
    plt.show()

# Main function to process uploaded files
def process_files(uploaded_files):
    for filename in uploaded_files.keys():
        cleaned_filename = clean_filename(filename)
        print(f"Processing: {cleaned_filename}")

        if cleaned_filename in BORDER_TEST_CASES:
            if 'frag' in cleaned_filename:
                handle_border_file(filename, ['black'])
            elif 'isolated' in cleaned_filename:
                handle_border_file(filename, ['red'])
            elif 'sol' in cleaned_filename:
                handle_border_file(filename, ['yellow'])
            elif 'occlusion1_rec' in cleaned_filename:
                display_image_file(filename)

        elif cleaned_filename in POLYGON_TEST_CASES:
            if 'occlusion1' in cleaned_filename:
                handle_polygon_file(filename, ['yellow', 'lightgreen'])
            elif 'occlusion2' in cleaned_filename:
                handle_polygon_file(filename, ['white'])

        else:
            print(f"Unknown file type: {cleaned_filename}. Skipping...")

# Upload files and process them
uploaded_files = files.upload()
print("Uploaded files:", uploaded_files.keys())
process_files(uploaded_files)